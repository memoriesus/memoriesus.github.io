---
post: page
title: GCD实践
tags: [iOS,GCD]
comment: true 
---

#GCD
GCD 中的DispatchQueue是先进先出的，以**Block**的方式来提交任务的
一般包含了以下2种：
* 1， Serial一连串的
* 2， concurrence 同时发生

Dispatch提交的任务会 通过系统管理的线程池来执行，除了Dispatch Queue在主线程中的执行系统不能保证哪个线程去执行这个任务；
一般而言，执行的任务的时候会有2种：
* 1， 同步
* 2，异步
当你计划任务同步时， 你的代码将会等待直到work item被执行完成，否则不会去执行的，尝试执行同步任务在主线程时候就会造成死锁
当你计划任务异步进行的时候，你的代码继续执行，然而其他的任务则在别处执行

#最佳实践

## 1， 消除过度的线程创建
当设定任务同时执行时候，别去调用阻塞主线程的方法

当一个任务计划通过一个同时派发队列阻塞一个线程，系统创建额外的线程去执行其他的队列化的同事任务；
如果太多的任务阻塞，系统将会**跳出你App的线程**
## 2，别去创建太多私有的dispatchQueue
如果太多的任务阻塞，系统将会**跳出你App的线程**
另外毕竟消耗太多线程是通过创建太多私有同时进行的DispatchQueue，因为每个派发队列都会消耗线程资源，创建
创建额外的线程派发队列会使线程消耗问题更加严重，提交任务到一个全局的并发队列；对于一连串的任务设置一个全局串行的队列
